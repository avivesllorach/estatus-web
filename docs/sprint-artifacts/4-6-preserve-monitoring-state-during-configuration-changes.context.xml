<?xml version="1.0" encoding="UTF-8"?>
<storyContext>
  <storyMetadata>
    <storyId>4-6-preserve-monitoring-state-during-configuration-changes</storyId>
    <title>Story 4.6: Preserve Monitoring State During Configuration Changes</title>
    <status>ready-for-development</status>
    <lastUpdated>2025-11-25T00:00:00Z</lastUpdated>
    <contextVersion>1.0</contextVersion>
  </storyMetadata>

  <!-- Core System Architecture -->
  <systemArchitecture>
    <component name="PingService" type="service" location="backend/src/services/pingService.ts">
      <description>Core monitoring service responsible for server pinging, SNMP disk monitoring, and NetApp LUN monitoring. Already implements delta-based update methods (addServers, removeServers, updateServers, onConfigChange) and uses Map-based state management.</description>
      <keyFeatures>
        <feature>Event-driven architecture with EventEmitter</feature>
        <feature>Map-based server status management (serverStatusMap)</feature>
        <feature>Delta-based configuration change support</feature>
        <feature>Concurrent ping loops with Promise tracking</feature>
        <feature>SNMP and NetApp monitoring intervals</feature>
      </keyFeatures>
      <methodsAvailable>
        <method name="onConfigChange" signature="onConfigChange(newServers: ServerConfig[]): Promise&lt;void&gt;" description="Main integration point for hot-reload functionality"/>
        <method name="addServers" signature="addServers(newServers: ServerConfig[]): Promise&lt;void&gt;" description="Add new servers without interrupting existing monitoring"/>
        <method name="removeServers" signature="removeServers(serverIdsToRemove: string[]): Promise&lt;void&gt;" description="Stop monitoring for specified servers"/>
        <method name="updateServers" signature="updateServers(updatedServers: ServerConfig[]): Promise&lt;void&gt;" description="Update configuration for existing servers"/>
        <method name="getAllServerStatus" signature="getAllServerStatus(): ServerStatus[]" description="Get current status of all monitored servers"/>
      </methodsAvailable>
      <eventsEmitted>
        <event name="statusChange" payload="StatusUpdate" description="Emitted when server online/offline status changes"/>
        <event name="diskUpdate" payload="DiskUpdate" description="Emitted when disk information changes"/>
      </eventsEmitted>
    </component>

    <component name="ConfigManager" type="service" location="backend/src/services/ConfigManager.ts">
      <description>Configuration management service with hot-reload capabilities and delta calculation. Already implements event-driven architecture and atomic file integration.</description>
      <keyFeatures>
        <feature>Event-driven configuration changes</feature>
        <feature>Delta calculation for server updates</feature>
        <feature>Atomic file write integration</feature>
        <feature>Performance optimization (&lt;2 second reload requirement)</feature>
      </keyFeatures>
      <eventsEmitted>
        <event name="servers-changed" payload="{servers, delta, timestamp}" description="General server configuration change event"/>
        <event name="servers-added" payload="ServerConfig[]" description="Specific event for added servers"/>
        <event name="servers-removed" payload="ServerConfig[]" description="Specific event for removed servers"/>
        <event name="servers-updated" payload="ServerConfig[]" description="Specific event for updated servers"/>
        <event name="groups-changed" payload="{groups, timestamp}" description="Group configuration changes"/>
      </eventsEmitted>
    </component>

    <component name="SSEBroadcaster" type="route" location="backend/src/routes/events.ts">
      <description>Server-Sent Events endpoint for real-time updates to frontend dashboard. Already handles all configuration change events without connection interruption.</description>
      <keyFeatures>
        <feature>Real-time statusChange events</feature>
        <feature>Real-time diskUpdate events</feature>
        <feature>Configuration change events (serverAdded/Removed/Updated)</feature>
        <feature>30-second heartbeat mechanism</feature>
        <feature>Graceful client disconnect handling</feature>
      </keyFeatures>
    </component>

    <component name="AtomicFileUtils" type="utility" location="backend/src/utils/fileUtils.ts">
      <description>Atomic file write utilities ensuring configuration integrity during updates. Already implemented and tested from Story 4.5.</description>
      <keyFeatures>
        <feature>writeConfigAtomic with temp file + rename pattern</feature>
        <feature>File permission preservation</feature>
        <feature>Error recovery and cleanup</feature>
        <feature>JSON formatting with 2-space indentation</feature>
      </keyFeatures>
    </component>
  </systemArchitecture>

  <!-- Integration Points and Event Flow -->
  <integrationFlow>
    <eventFlow name="Configuration Change Processing">
      <step order="1" component="ConfigManager" action="File change detected" description="ConfigManager detects file changes via file watching"/>
      <step order="2" component="ConfigManager" action="reloadServers()" description="Reloads server configuration and calculates delta"/>
      <step order="3" component="ConfigManager" action="Emit 'servers-changed' event" description="Broadcasts configuration delta with added/removed/updated servers"/>
      <step order="4" component="Server.ts" action="setupHotReloadListeners()" description="Listens for ConfigManager events in main server"/>
      <step order="5" component="PingService" action="onConfigChange()" description="Processes delta updates without full restart"/>
      <step order="6" component="PingService" action="Delta-based monitoring updates" description="addServers/removeServers/updateServers called as needed"/>
      <step order="7" component="SSEBroadcaster" action="Continuous event broadcasting" description="Status and disk updates continue without interruption"/>
    </eventFlow>

    <eventFlow name="SSE Connection Stability">
      <step order="1" component="SSEBroadcaster" action="Client connects" description="Initial connection with current server status"/>
      <step order="2" component="PingService" action="Continuous monitoring" description="Ongoing statusChange and diskUpdate events"/>
      <step order="3" component="ConfigManager" action="Configuration change" description="Emits serverAdded/Removed/Updated events"/>
      <step order="4" component="SSEBroadcaster" action="All events broadcast" description="No connection interruption during config changes"/>
      <step order="5" component="SSEBroadcaster" action="Heartbeat every 30s" description="Maintains connection stability"/>
    </eventFlow>
  </integrationFlow>

  <!-- Implementation Patterns and Standards -->
  <implementationPatterns>
    <pattern name="Delta Update Pattern" type="architecture">
      <description>Compare current vs new configurations to calculate minimal changes (added/removed/updated)</description>
      <implementation>
        <codeBlock language="typescript">
          <comment>From PingService.onConfigChange() method:</comment>
          const currentServerMap = new Map(this.servers.map(s => [s.id, s]));
          const newServerMap = new Map(newServers.map(s => [s.id, s]));

          const added = newServers.filter(s => !currentServerMap.has(s.id));
          const removed = this.servers.filter(s => !newServerMap.has(s.id));
          const updated = newServers.filter(s => {
            const current = currentServerMap.get(s.id);
            return current && JSON.stringify(current) !== JSON.stringify(s);
          });
        </codeBlock>
      </implementation>
    </pattern>

    <pattern name="Map-Based State Management" type="data-structure">
      <description>Use Map data structure for O(1) server state operations</description>
      <implementation>
        <codeBlock language="typescript">
          <comment>From PingService constructor:</comment>
          private serverStatusMap = new Map&lt;string, ServerStatus&gt;();
          private pingPromises = new Map&lt;string, Promise&lt;void&gt;&gt;();
          private snmpIntervals = new Map&lt;string, NodeJS.Timeout&gt;();
        </codeBlock>
      </implementation>
    </pattern>

    <pattern name="Graceful Monitoring Lifecycle" type="lifecycle">
      <description>Start/stop monitoring without affecting other servers</description>
      <implementation>
        <codeBlock language="typescript">
          <comment>Stop monitoring for specific server:</comment>
          private stopMonitoringForServer(serverId: string): void {
            this.pingPromises.delete(serverId);
            const snmpInterval = this.snmpIntervals.get(serverId);
            if (snmpInterval) {
              clearInterval(snmpInterval);
              this.snmpIntervals.delete(serverId);
            }
            this.serverStatusMap.delete(serverId);
          }
        </codeBlock>
      </implementation>
    </pattern>

    <pattern name="Event-Driven SSE Broadcasting" type="communication">
      <description>All status and configuration changes broadcast via SSE without connection reset</description>
      <implementation>
        <codeBlock language="typescript">
          <comment>From events.ts - continuous event broadcasting:</comment>
          pingService.on('statusChange', onStatusChange);
          pingService.on('diskUpdate', onDiskUpdate);
          configManager.on('servers-added', onServersAdded);
          configManager.on('servers-removed', onServersRemoved);
          configManager.on('servers-updated', onServersUpdated);
        </codeBlock>
      </implementation>
    </pattern>
  </implementationPatterns>

  <!-- Testing Infrastructure -->
  <testingInfrastructure>
    <framework name="Jest" location="backend/jest.config.js">
      <configuration>
        <preset>ts-jest</preset>
        <testEnvironment>node</testEnvironment>
        <testTimeout>30000</testTimeout>
        <coverageDirectory>coverage</coverageDirectory>
        <forceExit>true</forceExit>
        <clearMocks>true</clearMocks>
        <resetMocks>true</resetMocks>
        <restoreMocks>true</restoreMocks>
      </configuration>
    </framework>

    <existingTests>
      <test name="Atomic File Utilities" location="backend/src/__tests__/utils/fileUtils.test.ts">
        <description>Comprehensive tests for writeConfigAtomic functionality</description>
        <patterns>
          <pattern>Temp file + rename atomic pattern</pattern>
          <pattern>File permission preservation</pattern>
          <pattern>Error handling and cleanup</pattern>
          <pattern>Data integrity verification</pattern>
        </patterns>
      </test>
      <test name="Configuration Routes" location="backend/src/__tests__/routes/config.test.ts">
        <description>Integration tests for atomic writes to configuration files</description>
        <patterns>
          <pattern>Concurrent file operations</pattern>
          <pattern>JSON formatting verification</pattern>
          <pattern>Configuration structure validation</pattern>
        </patterns>
      </test>
    </existingTests>

    <testingPatterns>
      <pattern name="Mock Time for Performance Testing">
        <description>Use jest.useFakeTimers() to test monitoring continuity without real delays</description>
        <implementation>
          <codeBlock language="typescript">
            beforeEach(() => {
              jest.useFakeTimers();
            });

            it('should maintain monitoring during config changes', async () => {
              // Fast-forward time to simulate monitoring continuity
              jest.advanceTimersByTime(1000);
              // Verify no monitoring gaps
            });
          </codeBlock>
        </implementation>
      </pattern>

      <pattern name="Service Isolation Testing">
        <description>Test PingService delta updates with mocked dependencies</description>
        <implementation>
          <codeBlock language="typescript">
            it('should process delta updates independently', () => {
              const pingService = new PingService(initialServers);
              const addServersSpy = jest.spyOn(pingService, 'addServers');
              const removeServersSpy = jest.spyOn(pingService, 'removeServers');

              await pingService.onConfigChange(updatedServers);

              expect(addServersSpy).toHaveBeenCalledWith(addedServers);
              expect(removeServersSpy).toHaveBeenCalledWith(removedIds);
            });
          </codeBlock>
        </implementation>
      </pattern>
    </testingPatterns>
  </testingInfrastructure>

  <!-- Performance Requirements and Metrics -->
  <performanceRequirements>
    <requirement name="Monitoring Continuity" threshold="&lt;5 seconds">
      <description>Unaffected servers must have monitoring gaps less than 5 seconds</description>
      <target>0-2 seconds for state transition operations</target>
      <measurement>Time between last status update before config change and first status update after</measurement>
    </requirement>

    <requirement name="New Server Startup" threshold="&lt;5 seconds">
      <description>Newly added servers must start monitoring within 5 seconds</description>
      <measurement>Time from configuration save to first ping status event</measurement>
    </requirement>

    <requirement name="Server Removal Cleanup" threshold="&lt;1 second">
      <description>Removed servers must stop emitting events within 1 second</description>
      <measurement>Time from configuration change to last event emission</measurement>
    </requirement>

    <requirement name="SSE Connection Stability" threshold="0 disconnects">
      <description>SSE connections must remain stable during configuration changes</description>
      <measurement>Number of client disconnections during config operations</measurement>
    </requirement>

    <requirement name="Configuration Reload Performance" threshold="&lt;2 seconds">
      <description>Full configuration reload must complete within 2 seconds</description>
      <measurement>Time from file change detection to completion of all delta updates</measurement>
    </requirement>
  </performanceRequirements>

  <!-- Key Type Definitions -->
  <typeDefinitions>
    <type name="ServerConfig" location="backend/src/types/server.ts">
      <description>Core server configuration structure</description>
      <properties>
        <property name="id" type="string">Unique server identifier</property>
        <property name="name" type="string">Display name</property>
        <property name="ip" type="string">IP address for ping monitoring</property>
        <property name="dnsAddress" type="string">DNS address for monitoring</property>
        <property name="snmp" type="SnmpConfig">Optional SNMP configuration</property>
        <property name="netapp" type="NetAppConfig">Optional NetApp configuration</property>
      </properties>
    </type>

    <type name="ServerStatus" location="backend/src/types/server.ts">
      <description>Runtime monitoring status for servers</description>
      <properties>
        <property name="id" type="string">Server identifier</property>
        <property name="name" type="string">Server name</property>
        <property name="ip" type="string">Server IP</property>
        <property name="isOnline" type="boolean">Current online status</property>
        <property name="consecutiveSuccesses" type="number">Success count for status determination</property>
        <property name="consecutiveFailures" type="number">Failure count for status determination</property>
        <property name="lastChecked" type="Date">Last monitoring check timestamp</property>
        <property name="lastStatusChange" type="Date">Last status change timestamp</property>
        <property name="diskInfo" type="DiskInfo[]|null">Optional disk monitoring data</property>
      </properties>
    </type>

    <type name="StatusUpdate" location="backend/src/types/server.ts">
      <description>Status change event payload for SSE</description>
      <properties>
        <property name="serverId" type="string">Server identifier</property>
        <property name="name" type="string">Server name</property>
        <property name="ip" type="string">Server IP</property>
        <property name="isOnline" type="boolean">New online status</property>
        <property name="previousStatus" type="boolean">Previous online status</property>
        <property name="timestamp" type="Date">Change timestamp</property>
      </properties>
    </type>

    <type name="DiskUpdate" location="backend/src/types/server.ts">
      <description>Disk information update event payload</description>
      <properties>
        <property name="serverId" type="string">Server identifier</property>
        <property name="name" type="string">Server name</property>
        <property name="diskInfo" type="DiskInfo[]|null">Updated disk information</property>
        <property name="timestamp" type="Date">Update timestamp</property>
      </properties>
    </type>
  </typeDefinitions>

  <!-- Implementation Priorities and Constraints -->
  <implementationConstraints>
    <constraint name="No Breaking Changes">
      <description>Must maintain existing API contracts for SSE events and service methods</description>
      <impact>Frontend integration and existing functionality must remain unaffected</impact>
    </constraint>

    <constraint name="Event-Driven Architecture">
      <description>Must leverage existing EventEmitter-based communication patterns</description>
      <impact>All changes should integrate with ConfigManager.emit() and PingService.on() patterns</impact>
    </constraint>

    <constraint name="Memory Management">
      <description>Must prevent memory leaks from stopped monitoring intervals</description>
      <impact>All setInterval and Promise references must be properly cleaned up</impact>
    </constraint>

    <constraint name="Error Isolation">
      <description>Configuration changes must not crash monitoring service</description>
      <impact>Individual server failures should not affect other servers' monitoring</impact>
    </constraint>
  </implementationConstraints>

  <!-- Development Context and Prerequisites -->
  <developmentContext>
    <prerequisite name="Delta Infrastructure Ready" status="COMPLETE">
      <description>PingService already implements addServers/removeServers/updateServers methods</description>
      <location>backend/src/services/pingService.ts lines 414-676</location>
    </prerequisite>

    <prerequisite name="Event System Established" status="COMPLETE">
      <description>ConfigManager already emits servers-changed events with delta information</description>
      <location>backend/src/services/ConfigManager.ts lines 104-120</location>
    </prerequisite>

    <prerequisite name="SSE Broadcasting Stable" status="COMPLETE">
      <description>Events route already handles all configuration change events without disconnects</description>
      <location>backend/src/routes/events.ts lines 68-109</location>
    </prerequisite>

    <prerequisite name="Atomic File Operations" status="COMPLETE">
      <description>Atomic file write utilities ensure configuration integrity</description>
      <location>backend/src/utils/fileUtils.ts lines 16-56</location>
    </prerequisite>

    <prerequisite name="Testing Framework Ready" status="COMPLETE">
      <description>Jest configuration and test patterns established from previous stories</description>
      <location>backend/jest.config.js and existing test files</location>
    </prerequisite>
  </developmentContext>

  <!-- Key Integration Points for Implementation -->
  <keyIntegrationPoints>
    <point name="ConfigManager to PingService Communication">
      <description>Server.ts lines 93-104: setupHotReloadListeners() connects ConfigManager events to PingService.onConfigChange()</description>
      <implementationStatus>READY - Integration point exists and functional</implementationStatus>
    </point>

    <point name="PingService Delta Processing">
      <description>PingService.onConfigChange() method already implements full delta-based update logic</description>
      <implementationStatus>READY - Core functionality implemented and tested</implementationStatus>
    </point>

    <point name="SSE Event Broadcasting Continuity">
      <description>Events route maintains client connections during all configuration operations</description>
      <implementationStatus>READY - No interruption to SSE connections during config changes</implementationStatus>
    </point>

    <point name="Monitoring State Management">
      <description>PingService uses Map-based state management for O(1) add/remove/update operations</description>
      <implementationStatus>READY - Efficient state management already implemented</implementationStatus>
    </point>
  </keyIntegrationPoints>
</storyContext>